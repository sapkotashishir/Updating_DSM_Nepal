# we are preparing the data for Zinc and Boron separatelt because 
# New soil testing of Zinc and Boron is not done 
# We will use the same legacy dataset for Zinc and boron 

library(sf)
library(ggplot2)
library(knitr)
library(dplyr)
library(leaflet)
library(ggspatial)
setwd('C:/Users/SSAPKOTA/OneDrive - CIMMYT/DSM/DSM 2.0/CSISA/NSAF/DSM_workflow')
# read the legacy dataset for zinc and boron 
Nepal_legacy <- read.csv('./input/points_Nepal/Legacy_data/Nepal_legacy_dataset.csv')
Nepal_legacy <- Nepal_legacy %>% 
  select(ID,District,longitude,latitude,Zn,B,Year) %>% 
  rename(id = ID, Longitude = longitude, Latitude = latitude) 
Nepal_legacy$id <- as.character(Nepal_legacy$id)


# Identify the variable names in the legacy data 
Lon <- 'Longitude'
Lat <- 'Latitude'
pid <- 'id'

lyrid <- 'lyrid'
date <- 'Year'

upper_depth = 0 
lower_depth = 20

# add depths column 
Nepal_legacy$upper_depth <-  upper_depth
Nepal_legacy$lower_depth <-  lower_depth 

# specify the soil properties columns of interest 
soil_properties <- c("Zn","B")


# Replace 0, 999999  and negative values to NA 


Nepal_legacy[,soil_properties] = lapply(Nepal_legacy[,soil_properties], function(x){
  x[x==0 | x == 99999|x<0] = NA
  return(x) 
  })

# remove all zeroes and trim ditributions with 99.7% +/- 3sd 

Nepal_legacy_timmed <- Nepal_legacy %>% 
  mutate(across(all_of(soil_properties), ~ { 
    # step 1 : Replace zeros with NA 
    x <- ifelse(. == 0, NA, .)
    
    # step2: Trim values outside the 3sd 
    
    lower <- quantile(x, probs = 0.0015, na.rm = TRUE)
    upper <- quantile(x, probs = 0.9985, na.rm = TRUE)
    
    x<- ifelse (x<lower | x >upper, NA, x)
    
    return(x)
    
    }))


# redundant and duplicated rows 
# keep only the rows where the number of NA's is less than number of rows in the data frame 
data = Nepal_legacy_timmed %>% filter(rowSums(is.na(select(.,all_of(soil_properties))))<length(soil_properties))


# keep only the distinc instances, ignoring the SN and ID columns 
data = distinct(data, across(-c(id)), .keep_all = TRUE)

# First check that the remaining duplicates all fulfill the requirement that the soil properties are different measurements

duplicates = data %>%
  group_by(Latitude, Longitude) %>%
  filter(n() > 1) %>%
  ungroup()

# Remove the remaining duplicates from the data data
cleaned_data = anti_join(data, duplicates, by = 'id')


legacy_sf <- st_as_sf(cleaned_data, coords = c("Longitude","Latitude"),
                      crs = 4326)
# load the admin district boundary of Nepal 
dist_boundary <- read_sf('./input/other/admin_Nepal/Nepal_Districts.shp')
boundary_sf = st_transform(dist_boundary, st_crs(4326))

# Separate density plot for Zn
ggplot(cleaned_data) +
  geom_density(aes(x = Zn, fill = "Zn"), alpha = 0.5) +
  stat_function(fun = dnorm, args = list(mean = mean(cleaned_data$Zn, na.rm = TRUE), 
                                         sd = sd(cleaned_data$Zn, na.rm = TRUE)), 
                aes(color = "Zn (Normal)"), linetype = "dashed") +
  labs(title = "Density Plot for Zn", x = "Zn Concentration", y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("Zn" = "blue")) +
  scale_color_manual(values = c("Zn (Normal)" = "blue"))

# Separate density plot for Boron
ggplot(cleaned_data) +
  geom_density(aes(x = B, fill = "Boron"), alpha = 0.5) +
  stat_function(fun = dnorm, args = list(mean = mean(cleaned_data$B, na.rm = TRUE), 
                                         sd = sd(cleaned_data$B, na.rm = TRUE)), 
                aes(color = "Boron (Normal)"), linetype = "dashed") +
  labs(title = "Density Plot for Boron", x = "Boron Concentration", y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("Boron" = "green")) +
  scale_color_manual(values = c("Boron (Normal)" = "green"))


legacy_profile <- cleaned_data[,c("id","Longitude","Latitude")]
legacy_layers <- cleaned_data[,c("id","upper_depth","lower_depth","Year" ,"B", "Zn")]


# # export the cleaned data for modeling 
# write.csv(cleaned_data, "./input/points_Nepal/Zn_B_legacy.csv", row.names = FALSE)
# write.csv(legacy_profile, "./input/points_Nepal/Zn_B_legacy_pro.csv", row.names = FALSE)
# write.csv(legacy_layers, "./input/points_Nepal/Zn_B_legacy_layer.csv", row.names = FALSE)


